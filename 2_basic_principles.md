フレームワーク設計方針
==================

設計するのは、ウェブアプリケーションと呼ばれるウェブサーバー用のPHPスクリプトです。

#### 方針：フロント側のフーレムワーク

今回のフレームワークでは、httpリクエストを受け取ってからコントローラを呼び出すところ、それとビュー（Htmlなど）を返す部分について考えます。つまりORMなど、MVCでいうモデルは考えません。

ただし、DB接続の設定などが簡単にできることは必須です。


ウェブアプリケーションとは何か？
----------------

### HTTPの基本

想定している、ウェブアプリケーションの使い方です。
SymfonyのHttp-Foundationを基本に考えます。

```php
/*
 * まずはアプリケーションを構築する。
 */
$app = function_to_build_framework();

/*
 * アプリケーションを走らせる。
 */
$request  = Request::create($_SERVER); // 入力はHTTPリクエスト。
$response = $app->run($request); // 実行！
$response->render(); // httpリスポンスを返す
```

ここで、
*   $appがアプリケーション、
*   $requestはHTTPリクエスト、
*   $responseがHTTPリスポンス、

です。

$appを最初に構築。構築の仕方は、これから考えるので、ひとまず「function_to_build_framework」という関数で作ることとしてあります。

$appの入力が、HTTPリクエスト。要はSymfonyのRequestオブジェクトですね。HTTPリクエストの情報以外に、PHP独特の設定やセッションなども含むと考えます。

#### 方針：アプリケーションとリクエストの分離

今回の設計において、$requestと$responseがリクエストごとに異なる値を持ちますが、$appは常に同じ状態を保つことを目指したいと思います。

できれば、処理実行前と後で$appの状態が同じであるのが理想です。

これにより、アプリケーションオブジェクト（$app）とリクエスト＆リスポンスがキレイに分離されることになるのではないでしょうか。


#### 方針：リクエストに変数を集約する

上手く言葉が見つからないのですが…
リクエストごとに異なる変数は$requestに集約したいと思います。

そうなると$appはリクエスト前と後で同じ状態、ということになります。

実際には、マルチスレッドを使えるようにまで作れるかどうかは分かりませんが、こういうことを意識することで設計がスッキリするのではないかと期待しています。


HTTPスタック
-----------

StackPHPというプロジェクトがあります。
先で言う$appをつなげることで複雑な機能を実装しよう、ということです。印象で言えば、こんな感じ？

```php
$app = $app1( $app2( $app3( ... ) ) );
```

HTTPスタックとは、先に述べた、入力としてHTTPリクエストを受け取り、HTTPリスポンスを返すオブジェクトのことです。

小さなHTTPスタックを繋ぎ合わせることで複雑なウェブアプリケーションを作ります。HTTPだとリクエストが入力で、出力がレスポンスと決まっているので、組み合わせやすいのです。

#### 方針：HTTPスタックを基本にする

HTTPスタックのとしてアプリケーションを構築します。

ちなみに…
*   ミドルウェア：アプリケーションを構築するHTTPスタックの場合は
*   フィルター：条件により呼び出されるHTTPスタック（チェーンしてない）

と呼び方を変える場合があります。


例えば、RubyのRackやJavaのServletなどで使われている方法です。
実はPHPでも使われていて、StackPHPやSlimなどでもコードを見ることが出来ます。

Slimのコードを参考にすれば、次のようにHTTPスタックのチェーンを作成します。

```php
class HttpStack {
  protected $next;
  function call($request) {
    // do some job.
    $response = $this->next->call($request);
    // do more job.
    return $response;
  }
}
```

ここでは、$nextが次のミドルウェアで、次々と実行することができます。どこかのミドルウェアでリスポンスが帰ってきたら、チェーンは終わりです。今度は次々とリスポンスを返してゆきます。

> これはChain of Responsibility パターンになると思います。
> 一方、各HTTPスタックで$requestの内容を変更してゆくこともおおいので、decoratorパターンでもあります。

もう一つ。


#### 方針：できるだけHTTPスタックで機能を実現する

できるだけHTTPスタックでアプリケーションを構築する、ということです。

全てをスタックで表現できないと思いますが、少なくともURLのルーティングぐらいは十分可能です。

一方でスタックに合わない要素は出てくるはず。その場合は、
*   リクエストごとに異なる場合は$requestまたは$responseで、
*   それ以外は$appで、

実装します。

この「それ以外」とは、何があるのでしょうね。

思いつくのは、
*   設定、
*   イベンt・フック、
*   サービス、フィルター、もろもろのコンテナ、
*   テンプレート・ビュー、

あたりでしょうか。このへんも、後で設計したいと思います。


### その他、必要な機能

次のような機能が必要になると思いますが、おいおい考えてゆくことで。

コンフィグ
フィルター
サービス
DIコンテナ
テンプレートエンジン


DIコンテナについて
---------------

#### 方針：DIコンテナは、これを使わない。

わざと難しい日本語で書いてみた。

本当は使いたい。

ただ、PHPではDIコンテナの標準が確立されてない気がする。
ただ、PHPでDIコンテナを使うと遅くなる気がする。

なので、DIコンテナと呼ばれるものは使わない方向で。

ただし、DIは行う。
そして、ファクトリで代用してみる。

後、Ray.DIがver1.0になったので、それをチェックしてからもう一度考える。

