フレームワーク設計方針
==================

設計するのは、ウェブアプリケーションと呼ばれるウェブサーバー用のPHPスクリプトです。

#### 方針：フロント側のフーレムワークを設計する

今回のフレームワークでは、httpリクエストを受け取ってからコントローラを呼び出すところ、それとビュー（Htmlなど）を返す部分について考えます。つまりORMなど、MVCでいうモデルは考えません。

ただし、DB接続の設定などが簡単にできることは必須です。


ウェブアプリケーションとは何か？
----------------

### HTTPの基本

ウェブアプリケーションとは何をするものでしょう？
色々な答えがあると思いますが、一番スッキリとした定義は、次の一行です。

```php
$response = $app( $request );
```

この```$app```がウェブアプリケーションです。ウェブからきた```$request```（URLとかが入っていて）を受け取って、```$response```（HTMLやステータスが入っている）を返します。

これだけ！

つまり、上の３つについて、持っている情報や機能と構築方法を決定するのがウェブアプリケーションを設計することになります。

> 実際には```$app```はオブジェクトで、$app->callというようなメソッドを呼び出しているかもしれません。

#### 方針：アプリケーションとリクエストの分離

上の式において、```$app```は常に同じ状態を保つことを目指したいと思います。

できれば、処理実行前と後で$appの状態が同じであるのが理想です。何か変わる状態がある場合は、リソースに持ってもらいましょう。

これにより、アプリケーションオブジェクト（$app）とリクエスト＆リスポンスがキレイに分離されることになるのではないでしょうか。


#### 方針：リクエストに変数を集約する

一方、リクエストごとに異なる値は、```$request```と```$response```で表すことになります。

できれば、```$app```はリクエスト前と後で同じ状態でありたいです。つまり、```$app```では、リクエストやレスポンスをグローバル（オブジェクトのプロパティ）として持たない、ということになります。

> これはJavaなどのマルチスレッドだと大事な要件のようです。
> 
> 一方で、PHPではリクエストごとに違うプロセスで走るので、必要無い要件ということになります。ただ、こういうことを意識することで設計がスッキリするのではないかと期待しています。


HTTPスタック
-----------

StackPHPというプロジェクトがあります。前に[「StackPHPとミドルウェアについて調べてみた」](http://qiita.com/asaokamei/items/7ab97852cff5603f5145)をQiitaに投稿したことが有ります。

先の```$app```を次々と実行することで複雑なウェブアプリケーションの機能を実装しよう、ということ考えです。

多数の```$app```を積み重ねるというイメージから、スタックと呼ばれます。

例えば、RubyのRackやJavaのServletなどで使われている方法です。
実はPHPでも使われていて、StackPHPやSlimなどでもコードを見ることが出来ます。

小さなスタックを繋ぎ合わせることで複雑なウェブアプリケーションを作ります。ウェブアプリケーションでは、入力がリクエストで、出力がレスポンスと決まっているので、組み合わせやすいのです。

#### 方針：HTTPスタックを基本にする

この設計でも、スタックを使ってアプリケーションを構築します。

ちなみに…

*	__HTTPスタック__：ウェブアプリケーションのスタックということで、わざわざHTTPと呼ぶ場合があります。
*	__ミドルウェア__：特に途中に挟まれるHTTPスタックをミドルウェアと呼ぶ場合があります。
*   __フィルター__：条件により呼び出されるHTTPスタックで、チェーンしてない場合フィルターと呼ぶことがあります。

### Slimのスタック

具体的なスタックの方法を[Slim Framework](http://www.slimframework.com/)を使って見てみます。Slimでは、次のようにHTTPスタックのチェーンを作成します。

```php
class HttpStack {
  protected $next;
  function call($request) {
    // do some job.
    $response = $this->next->call($request);
    // do more job.
    return $response;
  }
}
```

ここでは、$nextが次のミドルウェアで、次々と実行することができます。どこかのミドルウェアでリスポンスが帰ってきたら、チェーンは終わりです。今度は次々とリスポンスを返してゆきます。

> これはChain of Responsibility パターンになると思います。
> 
> 一方、各HTTPスタックで$requestの内容を変更してゆくこともおおいので、decoratorパターンでもあります。


#### 方針：できるだけHTTPスタックで機能を実現する

できるだけHTTPスタックでアプリケーションを構築する、ということです。

全てをスタックで表現できないと思いますが、少なくともURLのルーティングぐらいは十分可能です。

一方でスタックに合わない要素は出てくるはず。その場合は、

*   リクエストごとに異なる場合は$requestまたは$responseで、
*   それ以外は$appで、

実装します。

この「それ以外」とは、何があるのでしょうね。

思いつくのは、

*   設定、
*   サービス、フィルター、管理用DIコンテナ、
*   イベント・フック、
*   テンプレート・ビュー、

あたりでしょうか。このへんも、後で設計したいと思います。


